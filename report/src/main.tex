%! Author = metametamoon
%! Date = 1/27/25

% Preamble
\documentclass[11pt]{article}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

% Packages
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsfonts}
\usepackage{amssymb}



\newcommand{\realpositive}{\mathbb{R}_{\geqslant 0}}
\DeclareMathOperator*{\argmin}{arg\,min}
% Document
\begin{document}
     \section{Мотивация}
     Во многих областях искуственного интеллекта естественным образом появляется планирования путей на больших графах.
     Большая часть исследований в этой задаче покрывает задачу в случае, когда граф нам целиком известен заранее.
     Однако многим системам приходится сталкиваться с динамическими изменениями в графе и приходиться адаптироваться к изменившимся условиям, поскольку предыдущий итог планирования может потерять актуальность

     \section{Постановка задачи}
     Пусть нам дан граф $G = (V, E)$, где $V$ --- конечное множество вершин, $E \subset V \times V \times \realpositive$ --- множество взвешенных ребер.
     При этом будем считать, что в графе нет кратных ребер, ввиду чего можно ввести функцию веса ребра $w: V \times V \rightarrow {\realpositive \lor \infty}$
     Путем в графе будем называть конечную последовательность $A = [v_1, v_2, \dots, v_n]$ такую, что для каждого $i = 1, \dots, n-1$: $w(v_i, v_{i+1}) \neq \infty$ для некоторого $w \in \mathbb{R}_{\geqslant 0}$.
     Множество конечных последовательностей вершин мы будем обозначать $P = P(V)$.
     Весом пути мы будем называть выражение $w(A) = \sum_{i = 1}^{n-1} w(v_i, v_{i+1})$.
     Началом пути мы будем называть при этом первый элемент последовательности и обозначать $s(A)$, а концом пути --- последний элемент последовательности, и обозначать $d(A)$.

     Мы хотим решать задачу минимального пути --- нам даны вершины $s, d \in V$  (далее мы считаем, что $s, d, V$ фиксированы) и мы должны найти
     $$A_{plan}= \argmin_{\substack{A \subset V \text{ --- путь в } G \\ s(A) = s \\ d(A) = d}} w(A).$$
     Мы будем также говорить тогда, что $A = \mathtt{optpath}(G, s, d)$.

     \pagebreak
     \newcommand{\fplan}{\mathtt{plan}}
     \newcommand{\fextract}{\mathtt{extract}}
     \newcommand{\fempty}{\mathtt{empty}}
     Сформулируем более точно алгоритмическую задачу.
     На $i$-ом шаге мы получаем информацию $E_i \subset V \times V \times \realpositive \lor \infty$ об изменении весов ребер в графе.
     Тогда \textit{алгоритмом для решения задачи долгосрочного планирования} мы будем называть тройку $(T, \fplan, \fextract)$ из произвольного множества и двух вычислимых фукнций соответственно, такую что:
     \begin{align*}
          &\fempty \in T \\
          &\fplan: E \times T \rightarrow T \\
          &\fextract: T \rightarrow P(V) \\
          &\fextract(\fplan(E, \fempty)) = \mathtt{optpath}(G, s, d) \\
          &\fextract(t_0) = \mathtt{optpath}((V, E'), s, d) \rightarrow \\
          &\qquad \fextract(\fplan(E_{new}, t_0)) = \mathtt{optpath}((V, E' \leftarrow E_{new}), s, d)
     \end{align*}

     Мы будем применять алгоритм в следующем коде (который следует рассматривать как синтаксический сахар над машиной Тьюринга):
     \begin{verbatim}
active_plan = empty
for i in 1..n:
     e_new_i = get_e_new_i()
     active_plan = plan(e_new_i, active_plan)
     shortest_path = extract(active_plan)
     \end{verbatim}
     Несложно заметить, что функция $\fplan$, которая запускает поиск пути заново, используя из предыдущих своих итераций только информацию о весах ребер, тривиально удовлетворяет всем этим свойствам.
     Однако в случае, когда размер $E_{new}$ мал по сравнению с размером $E$, полное перевычисление кратчайшего пути оказывается избыточным.
     Мы бы хотели минимизировать число итераций алгоритма $\fplan$ и $\fextract$ в ходе исполнения псевдокода выше.


\begin{lstlisting}[language=Python, caption=A*]
def Main(start, goal):
     U = {}
     Q = {}
     Q.push(start)
     g[start] = 0
     f[start] = g[start] + h(start)
     while Q.size() != 0
          current = Q.top() // vertex with minimal f-value
          if current == goal
               return true  // path found
          Q.remove(current)
          U.push(current)
          for v : N(current)
               // d(current, v) --- cost of passing from current to v
               tentativeScore = g[current] + d(current, v)
               if v in U and tentativeScore >= g[v]
                    continue
               if v in U or tentativeScore < g[v]
                    parent[v] = current
                    g[v] = tentativeScore
                    f[v] = g[v] + h(v)
                    if v in Q
                         Q.push(v)
     return false
\end{lstlisting}



\begin{lstlisting}[language=Python, caption=SWSFP]
def computeRHS(p)
     rhs(point) = infinity
     for n in N(p):
          rhs(point) = min(d(n) + cost(p, n), rhs(p))

def computeKey(p):
     return min(d(o), rhs(p))


def checkInconsistency(p):
     if rhs(point) != d(point):
          inconsistentVertices.insert((computeKey(point), point))

def updateNeigboursAndVertex(p):
     for n in N(p):
          computeRHS(n)
          checkInconsistency(n)
     computeRHS(point)
     checkInconsistency(point)

def computePath():
     while inconsistentVertices:
          key, u = inconsistentVertices.top()
          inconsistentVertices.erase((key, u))
          if rhs(u) == d(u):
               continue
          if rhs(u) < d(u):
               d(u) = rhs(u)
          else:
               d(u) = infinity
          updateNeigboursAndVertex(u)

def Initialize():
     rhs = dict()
     d = dict()
     inconsistentVertices = {}
     // set all rhs to infinity by default
     // set all d to infinity by default
     rhs[goal] = 0
     inconsistentVertices.add((computeKey(goal), goal));
     ComputePath()

def Main():
     Initialize()
     while (start != goal):
          if (d(start) == infinity_cost)
               return false
          start = // select neighbours of start with minimal d value
          for n in changedEdges:
               updateNeigboursAndVertex(n)
          updateNeigboursAndVertex(start)
          computePath()
\end{lstlisting}


\begin{lstlisting}[language=Python, caption=D* lite ]
def CalculateKey(s):
     return (min(g(s), rhs(s) + h(s), min(g(s), rhs(s))))
def Initialize():
     U = dict()
     for s in S:
          rhs(s) = g(s) = infinity
     rhs(start) = 0
     U.insert((start, (h(start), 0)))

def UpdateVertex(u):
     if u != start:
          rhs(u) =min([g(v) + c(v, u) for v in pred(u)])
     if u in U:
          U.remove(u)
     if g(u) != rhs(u):
          U.insert(u, CalculateKey(u))

def ComputeShortestPath():
     while U.topKey() < CalculateKey(goal) or rhs(goal) != g(goal):
          u = U.pop()
          if g(u) > rhs(u):
               g(u) = rhs(u)
               for s in succ(u):
                    UpdateVertex(s)
          else:
               g(u) = infinity
               for s in succ(u) + {u}:
                    UpdateVertex(s)

def Main():
     Initialize()
     while True:
          ComputeShortestPath()
          // make move along the shortest path to goal
          for (u, v) in observedEdges:
               UpdateVertex(u)
               UpdateVertex(v)
\end{lstlisting}


\end{document}