%! Author = metametamoon
%! Date = 1/27/25

% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsfonts}
\usepackage{amssymb}


\newcommand{\realpositive}{\mathbb{R}_{\geqslant 0}}
\DeclareMathOperator*{\argmin}{arg\,min}
% Document
\begin{document}
     \section{Мотивация}
     Во многих областях искуственного интеллекта естественным образом появляется планирования путей на больших графах.
     Большая часть исследований в этой задаче покрывает задачу в случае, когда граф нам целиком известен заранее.
     Однако многим системам приходится сталкиваться с динамическими изменениями в графе и приходиться адаптироваться к изменившимся условиям, поскольку предыдущий итог планирования может потерять актуальность

     \section{Постановка задачи}
     Пусть нам дан граф $G = (V, E)$, где $V$ --- конечное множество вершин, $E \subset V \times V \times \realpositive$ --- множество взвешенных ребер.
     При этом будем считать, что в графе нет кратных ребер, ввиду чего можно ввести функцию веса ребра $w: V \times V \rightarrow {\realpositive \lor \infty}$
     Путем в графе будем называть конечную последовательность $A = [v_1, v_2, \dots, v_n]$ такую, что для каждого $i = 1, \dots, n-1$: $w(v_i, v_{i+1}) \neq \infty$ для некоторого $w \in \mathbb{R}_{\geqslant 0}$.
     Множество конечных последовательностей вершин мы будем обозначать $P = P(V)$.
     Весом пути мы будем называть выражение $w(A) = \sum_{i = 1}^{n-1} w(v_i, v_{i+1})$.
     Началом пути мы будем называть при этом первый элемент последовательности и обозначать $s(A)$, а концом пути --- последний элемент последовательности, и обозначать $d(A)$.

     Мы хотим решать задачу минимального пути --- нам даны вершины $s, d \in V$  (далее мы считаем, что $s, d, V$ фиксированы) и мы должны найти
     $$A_{plan}= \argmin_{\substack{A \subset V \text{ --- путь в } G \\ s(A) = s \\ d(A) = d}} w(A).$$
     Мы будем также говорить тогда, что $A = \mathtt{optpath}(G, s, d)$.

     \pagebreak
     \newcommand{\fplan}{\mathtt{plan}}
     \newcommand{\fextract}{\mathtt{extract}}
     \newcommand{\fempty}{\mathtt{empty}}
     Сформулируем более точно алгоритмическую задачу.
     На $i$-ом шаге мы получаем информацию $E_i \subset V \times V \times \realpositive \lor \infty$ об изменении весов ребер в графе.
     Тогда \textit{алгоритмом для решения задачи долгосрочного планирования} мы будем называть тройку $(T, \fplan, \fextract)$ из произвольного множества и двух вычислимых фукнций соответственно, такую что:
     \begin{align*}
          &\fempty \in T \\
          &\fplan: E \times T \rightarrow T \\
          &\fextract: T \rightarrow P(V) \\
          &\fextract(\fplan(E, \fempty)) = \mathtt{optpath}(G, s, d) \\
          &\fextract(t_0) = \mathtt{optpath}((V, E'), s, d) \rightarrow \\
          &\qquad \fextract(\fplan(E_{new}, t_0)) = \mathtt{optpath}((V, E' \leftarrow E_{new}), s, d)
     \end{align*}

     Мы будем применять алгоритм в следующем коде (который следует рассматривать как синтаксический сахар над машиной Тьюринга):
     \begin{verbatim}
active_plan = empty
for i in 1..n:
     e_new_i = get_e_new_i()
     active_plan = plan(e_new_i, active_plan)
     shortest_path = extract(active_plan)
     \end{verbatim}
     Несложно заметить, что функция $\fplan$, которая запускает поиск пути заново, используя из предыдущих своих итераций только информацию о весах ребер, тривиально удовлетворяет всем этим свойствам.
     Однако в случае, когда размер $E_{new}$ мал по сравнению с размером $E$, полное перевычисление кратчайшего пути оказывается избыточным.
     Мы бы хотели минимизировать число итераций алгоритма $\fplan$ и $\fextract$ в ходе исполнения псевдокода выше.



\begin{verbatim}
bool A*(start, goal):
     U = {}
     Q = {}
     Q.push(start)
     g[start] = 0
     f[start] = g[start] + h(start)
     while Q.size() != 0
          current = Q.top() // vertex with minimal f-value
          if current == goal
               return true  // path found
          Q.remove(current)
          U.push(current)
          for v : N(current)
               // d(current, v) --- cost of passing from current to v
               tentativeScore = g[current] + d(current, v)
               if v in U and tentativeScore >= g[v]
                    continue
               if v in U or tentativeScore < g[v]
                    parent[v] = current
                    g[v] = tentativeScore
                    f[v] = g[v] + h(v)
                    if v in Q
                         Q.push(v)
     return false
\end{verbatim}



\end{document}